# 자료구조

### 자료구조

자료구조란 여러 데이터를 저장하는 구조 배열, 슬라이스 등도 자료구조의 일종

리스트와 링은 container 패키지에 속함

맵은 기본 내장 타입

### 종류

### List

리스트는 기본 자료구조로서 여러 데이터를 보관할 수 있다.

**배열은 연속된 메모리에 데이터를 저장**하는 반면 

**리스트**는 **불 연속된 메모리에 데이터를 저장**한다.

리스트는 각 데이터를 담고 있는 요소들을 **포인터**로 연결한 자료구조

요소들이 **포인터로 연결**됐다고 해서 **Linked List**라고 부르기도 한다.

```go
type Element struct{
Value interface{}
Next *Element
Prev *Element
}
```

**Element** 구조체는 리스트의 각  요소 데이터를 저장한다.

**Value**는 실제 요소의 데이터를 저장한 필드 빈 인터페이스 타입 이므로 모든 타입 저장 가능

**Next**는 *Element 타입으로 다음 Element 인스턴스의 메모리 주소를 가지고 Next를 사용해 다음 요소 인스턴스로 접근가능(포인터를 통해 연결)

**Prev**도 동일하나 Prev로 이전 요소 인스턴스 접근 가능함

→포인터로 양방향으로 연결되어 있어 다음, 이전 요소에 접근 가능함

→**양방향 리스트**

각 Element 주소가 일관성이 없다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3df7714-4502-424c-9441-0f87bef845f6/Untitled.png)

**리스트 기본 사용법**

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	v := list.New()//새로운 리스트 인스턴스 v생성
	e4 := v.PushBack(4)//인스턴스 v의 맨 뒤에 Value가 4인 요소 추가
	e1 := v.PushFront(1)//인스턴스 v의 맨앞에 Value가 1인 요소 추가
	v.InsertBefore(3, e4)//두번 째 인수로 입력된 요소 앞 새 요소 추가
	v.InsertAfter(2, e1)//두번 째 인수로 입력된 요소 뒤 새 요소 추가
	for e := v.Front(); e != nil; e = e.Next() {
		fmt.Print(e.Value, " ")
	}
	fmt.Println()
	for e := v.Back(); e != nil; e = e.Prev() {
		fmt.Print(e.Value, " ")
	}
}

//result
/*
1 2 3 4
4 3 2 1

주소값으로 변경하여 출력해본 결과
0xc000076528 0xc000076588 0xc000076558 0xc0000764f8
로 연속되지 않음을 확인 할 수 있었다.
*/
```

**************리스트 생성: list.New() 함수**************

******************************************************************리스트 뒤 요소 추가: PushBack(요소)******************************************************************

****************************리스트 앞 요소 추가:PushFront(요소)****************************

********************************************************************************특정 요소 앞 요소 삽입:InsertBefore(요소,대상요소)********************************************************************************

************************************************************************특정 요소 뒤 요소 삽입:InsertAfter(요소,대상요소)************************************************************************

******************************리스트 순회******************************

**********************************************************************************리스트의 첫번 째 요소 반환: Front()**********************************************************************************

**********************************************************************************리스트의 마지막 요소 반환 Back()**********************************************************************************

************************리스트의 현재 요소의 다음 요소 반환 Next()  다음 요소 미 존재시 nil 반환************************

****************************************************************************리스트의 현재 요소의 이전 요소 반환 Prev() 이전 요소 미 존재시 nil 반환****************************************************************************

### 배열 vs 리스트

**********************시간복잡도**********************

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6c73825-6c23-417d-8b9b-eaf55e685ca7/Untitled.png)

**배열은 절대적으로 삽입과 삭제에 O(N)이 든다.**

**왜냐하면 삽입 또는 삭제시 나머지 인덱스를 밀어야한다.**

**리스트의 경우에는 삽입 삭제를 수행할 때 리스트의 앞에 있다면 O(1)이 들겠지만**

**만약 내가 중간에  있는 인덱스에 삭제 또는 삽입 하려면 그 곳을 찾아가는데 O(N)이 소요되므로** 

**실제 시간복잡도는 O(N)이 걸릴 것이다.**

### 데이터 지역성(Data Locality)

**데이터 지역성**은 데이터가 밀집한 정도를 뜻함

배열과 리스트 선택시 고려해야 할 사항이다.

컴퓨터는 연산할 때 읽어온 데이터를 **캐시**라는 임시 저장소에 보관한다. 이때 **정확히 필요한 데이터만을 가져오지 않고 주변 데이터를 같이 가져온다**. 보통 연산이 일어난 다음에 높은 확률로 주변 데이터에 대한 연산이 이루어지기 때문이다.

이에 따라 필요한 데이터가 인접해 있을수록 처리 속도가 빨라지게 된다.

이를 데이터 지역성이 좋다고 말한다.

이를 토대로 살펴보면

**배열**은 **연속된 메모리**로 이루어진 자료구조 이고 **리스트**는 **불연속**이다.

따라서 **배열이 리스트에 비해 데이터 지역성이 뛰어나다.**

**원래라면 삽입과 삭제가 빈번할 시 리스트가 배열보다 좋다고 말하지만 요소의 수가 적어진다면 지역성으로 인하여 배열이 리스트보다 더 효율적이다.**

자세한 내용은 28장을 통해 알아본다.

### Queue

### 큐

큐는 먼저 입력된 값이 먼저 출력되는 **************************FIFO 자료구조************************** 

들어간 순서 그대로 빠져나오기 때문에 순서가 유지됨

새로운 요소는 항상 맨 마지막에 추가됨

출력값은 맨 앞에서 하나씩 빼내게 됨

```go
package main

import (
	"container/list"
	"fmt"
)

type Queue struct {
	v *list.List //list 를 이용한 큐 구조체 정의
}

func (q *Queue) Push(val interface{}) {//Queue 구조체의 메서드
	q.v.PushBack(val)
}
func (q *Queue) Pop() {////Queue 구조체의 메서드
	front := q.v.Front()
	if front != nil {
		fmt.Print(q.v.Remove(front), "->")
	} else {
		fmt.Println()
		fmt.Println("큐가 비어있음")
	}
}
func NewQueue() *Queue {
	return &Queue{list.New()}
}

func main() {
	queue := NewQueue()
	for i := 0; i < 5; i++ {
		queue.Push(i)
	}

	for i := 0; i < 6; i++ {
		queue.Pop()
	}
}

//result
/*
0->1->2->3->4->
큐가 비어있음
*/
```

### Stack

### 스택

스택은 마지막에 들어간 것이 먼저 나오는 **LIFO** 자료구조

가장 최근에 넣은 것 부터 역순으로 나오게 됨

요소는 맨뒤로 추가

요소를 뺄 때도 맨 뒤에서 뺌

스택은 순서가 반대가 되기 때문에 가장 최신 것 부터 하나씩 되돌릴 때 주로 사용 ****

**함수 호출에도 스택을 사용된다. 예를들어 a()→b()→c()함수순으로 호출하면 역순으로 반환해야 되기 때문에 큐를 사용한다**

```go
package main

import (
	"container/list"
	"fmt"
)

type Stack struct {
	v *list.List
}

func (s *Stack) Push(val interface{}) {
	s.v.PushBack(val)
}

func (s *Stack) Pop() {
	back := s.v.Back()
	if back != nil {
		fmt.Print(s.v.Remove(back), "->")
	} else {
		fmt.Println()
		fmt.Println("스택이 비어있습니다.")
	}
}

func NewStack() *Stack {
	return &Stack{list.New()}
}

func main() {
	stack := NewStack()
	for i := 0; i < 5; i++ {
		stack.Push(i)
	}
	for i := 0; i < 6; i++ {
		stack.Pop()
	}

}

//result
/*
4->3->2->1->0->
스택이 비어있습니다.
*/
```

### Ring

맨 뒤의 요소와 맨 앞의 요소가 서로 연결된 자료구조

리스트를 기반으로 만들어진 자료구조로 **원형으로 연결되어 있기 때문에 환형 리스트**라고 부름

**링** 자료구조에는 **시작과 끝이 존재하지 않음 단지 현재 위치가 존재**

**링**은 **저장할 개수가 고정되고, 오래된 요소는 지워도 되는 경우가 적합**

ex) 실행 취소 ctrl+Z 기능

     고정 크기 버퍼 기능 데이터에 따라 버퍼가 증가되지 않고 고정된 길이로 사용할 때

     리플레이 기능: 게임 등 최근 플레이 10초를 다시 리플레이 할 때와 같이 고정된 길이의 리플       

                              레이 기능 제공할 때

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63605dc0-196d-4a6d-9145-edf6d97fc490/Untitled.png)

```go
package main

import (
	"container/ring"
	"fmt"
)

func main() {
	r := ring.New(5)
	n := r.Len()

	for i := 0; i < n; i++ {
		r.Value = 'A' + i
		r = r.Next()
	}
	for j := 0; j < n; j++ {
		fmt.Printf("%c", r.Value)
		r = r.Next()
	}
	fmt.Println()

	for i := 0; i < n; i++ {
		fmt.Printf("%c", r.Value)
		r = r.Prev()
	}
}

//result
/*
ABCDE
AEDCB
*/
```

링의 **Next() 메서드는 다음 요소 인스턴스를 반환** 전체 요소 개수가 5이고 5번 이동하기 때문에 각 요소를 순회하면 현재 위치로 돌아온다.

### 맵
